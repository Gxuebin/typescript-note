{"./":{"url":"./","title":"Typescript 小书入门篇","keywords":"","body":"近3年，这家伙很火。🔥 到什么程度？一度没朋友，一度让我心头热了（冷笑话） 感性选择（内驱和兴趣使然） 就我来说，我还是一个不太理性的前端，截止到今年，看到哪门语言火热就去凑个热度，然后学学就丢了。3月份加入掘金，就暗暗给自己作了一个规划前端知识沉淀。其实也是在自我约束，约束那颗散漫（懒散又漫无目的）的心，要安安静静地做好一件事然后再去做下一件事。 其实 Typescript 基本语法已经撸过一遍，只是一直未在项目中实战，所以又丢了（这个毛病得改，改后还是好前端）。这次决心学并用，是因为本来是想解读 React 16.8.6 源码的，可是源码是 Typescript 写的，脑袋翁的一声，只好转头瞄准她了。不可否认，Typescript 本身的魅力也有吸引我，再加上自己也想在 React 项目中将她付诸于实践。综合了这 3 点决定干（是学）！！！。 理性选择（数据说话） 希望下面几个有影响力的数据趋势站点，能点燃你学习 Typescript 的兴趣。当然了，现在她还不是一门非必学语言。 Google Trends 第1组就是来自 Google Trends 。题外话，如果你想了解一个或多个事物或技术的发展趋势，Google Trends 是个不错的工具。 这里拿了近3年比较🔥的前端新贵（这里有一个是传统新贵）来做对比的（按火热程度的纬度来对比，虽然她们性质和使用场景的可比性不大），主要目的是想让正在阅读的你有个初步了解，Typescript 是一种趋势。 Stack Overflow Treads 第2组来自我们熟悉的 Stack Overflow Treads。题外话，Stack Overflow 就是那个遇到任何技术问题都可以去找答案的问答社区。 The State of JS 第3组报告来自 The State of JS 席卷开源社区 前端开源项目 angular、VScode、Vue3.0、Rxjs、TypeScript（本身）、Mobx、deno、Antd 等都采用了 Typescript 开发，React 采用 flowType，和 Typescript。显然，这是大趋势越，包括 Facebook 自家的 Jest 也宣布从 flowType 转向 typeScript。在这些大厂强力带动下，TypeScript 与我势在必行（没有懒得借口了）。 解决之前什么问题 前端报错前几名中必有 Uncaught TypeError，然而这是最最低级且不该犯的错误。我们知道 Javascript 是动态语言，运行时才会报错。 如果采用了 Typescript，完整的类型定义会帮助我们 能够在编码时很好的规避掉； 减少非常多的沟通成本和文档编写成本，最好的文档就是类型嘛（考量一个程序员的自我修养）； 前后端合作便利； 阿里 MidwayJs Team 的负责人在 GMTC 上说 “TypeScript，来帮助我们解决这些质量，习惯，方法上的问题，就拿 midway 团队来说，自从使用了 TypeScript，质量提升的非常明显，平常需要测试很久的代码，几乎不会出现低级的问题，反而暴露出的大多都是逻辑问题。” 同事声称 “ 今年，我们希望新应用全量使用 TS”。 终于 感性的认识和理性的选择都推动着去学习和应用，那就来吧。 You can 前端知识沉淀 下一篇：Typescript 精彩履历 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"introduction/":{"url":"introduction/","title":"扫盲篇","keywords":"","body":"扫盲篇 Typescript 为什么选择她 Typescript 精彩履历 Typescript 的成长环境 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"introduction/why.html":{"url":"introduction/why.html","title":"Typescript 为什么选择她","keywords":"","body":"近3年，这家伙很火。🔥 到什么程度？一度没朋友，一度让我心头热了（冷笑话） 感性选择（内驱和兴趣使然） 就我来说，我还是一个不太理性的前端，截止到今年，看到哪门语言火热就去凑个热度，然后学学就丢了。3月份加入掘金，就暗暗给自己作了一个规划前端知识沉淀。其实也是在自我约束，约束那颗散漫（懒散又漫无目的）的心，要安安静静地做好一件事然后再去做下一件事。 其实 Typescript 基本语法已经撸过一遍，只是一直未在项目中实战，所以又丢了（这个毛病得改，改后还是好前端）。这次决心学并用，是因为本来是想解读 React 16.8.6 源码的，可是源码是 Typescript 写的，脑袋翁的一声，只好转头瞄准她了。不可否认，Typescript 本身的魅力也有吸引我，再加上自己也想在 React 项目中将她付诸于实践。综合了这 3 点决定干（是学）！！！。 理性选择（数据说话） 希望下面几个有影响力的数据趋势站点，能点燃你学习 Typescript 的兴趣。当然了，现在她还不是一门非必学语言。 Google Trends 第1组就是来自 Google Trends 。题外话，如果你想了解一个或多个事物或技术的发展趋势，Google Trends 是个不错的工具。 这里拿了近3年比较🔥的前端新贵（这里有一个是传统新贵）来做对比的（按火热程度的纬度来对比，虽然她们性质和使用场景的可比性不大），主要目的是想让正在阅读的你有个初步了解，Typescript 是一种趋势。 Stack Overflow Treads 第2组来自我们熟悉的 Stack Overflow Treads。题外话，Stack Overflow 就是那个遇到任何技术问题都可以去找答案的问答社区。 The State of JS 第3组报告来自 The State of JS 席卷开源社区 前端开源项目 angular、VScode、Vue3.0、Rxjs、TypeScript（本身）、Mobx、deno、Antd 等都采用了 Typescript 开发，React 采用 flowType，和 Typescript。显然，这是大趋势越，包括 Facebook 自家的 Jest 也宣布从 flowType 转向 typeScript。在这些大厂强力带动下，TypeScript 与我势在必行（没有懒得借口了）。 解决之前什么问题 前端报错前几名中必有 Uncaught TypeError，然而这是最最低级且不该犯的错误。我们知道 Javascript 是动态语言，运行时才会报错。 如果采用了 Typescript，完整的类型定义会帮助我们 能够在编码时很好的规避掉； 减少非常多的沟通成本和文档编写成本，最好的文档就是类型嘛（考量一个程序员的自我修养）； 前后端合作便利； 阿里 MidwayJs Team 的负责人在 GMTC 上说 “TypeScript，来帮助我们解决这些质量，习惯，方法上的问题，就拿 midway 团队来说，自从使用了 TypeScript，质量提升的非常明显，平常需要测试很久的代码，几乎不会出现低级的问题，反而暴露出的大多都是逻辑问题。” 同事声称 “ 今年，我们希望新应用全量使用 TS”。 终于 感性的认识和理性的选择都推动着去学习和应用，那就来吧。 You can 前端知识沉淀 上一篇：Typescript 小书入门篇 下一篇：Typescript 精彩履历 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"introduction/introduction.html":{"url":"introduction/introduction.html","title":"Typescript 精彩履历","keywords":"","body":" 本章节和后续章节都以 Typescript 的口吻自述，就是这么自信（自恋）。 兵法云：知己知彼，百战不殆（语出《孙子·谋攻篇》）（一个前端开始聊兵法，瞎搞，凑字数）。引用此，是想说，要用我就先看看我漂亮履历吧。 自我介绍 我是 Microsoft 公司注册商标（来头大，后台硬）。 我是 JavaScript 的一个超集，主要提供类型系统和对 ES6 的支持。 我可以编译成纯的 JavaScript 代码，支持任意浏览器，任意环境，任意系统并且是开源的，开源于 GitHub 上。 我还在不断的完善中，会不断有新的特性加进来，所以你得时常关注我的成长。 如果你对我一见钟情，那就好好了解熟悉我； 如果你对我爱的山无棱天地合，那就在项目中应用我； 如果你对我没感觉，那继续回去写你的 Javascript 吧。 我好在哪里 增强代码的可读性和可维护性 在编译阶段就可以发现大部分错误，总比在运行时候出错好，你说呢？ 类型系统是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了； 增强了编辑器和 IDE 的功能，比如代码补全、接口提示、跳转到定义、重构等； 我有包容心 .js 文件可以直接重命名为 .ts 即可; 可以定义从简单到复杂的几乎一切类型; 即使不显式的定义类型，也能够自动做出类型推论; 即使在我这边编译报错，也可以生成 JavaScript 文件; 兼容第三方库，即使第三方库不是用我写的，也可以编写单独的类型文件给我读取; 拥有强大活跃的社区 符合 ES6 规范，也支持部分 ESNext 草案的规范（有眼光）； 大部分第三方库都有提供给我的类型定义文件（圈内有名，后台硬）; Google 开发的 Angular2 就是用我来编写的（傲娇）; ... 当然了，我也不是完美的 学习并熟悉我是需要一定的学习成本的，你需要了解什么是接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师不是很熟悉的概念和定义; 短期会增加开发成本，要多写一些类型的定义，不过对于长期维护的项目，用我了就能够减少维护成本; 集成到构建流程需要工作量; 和一些库结合的还不是很完美（其实，不完美也是一种美）; 客观地说 本章最后，我想对你说的是：根据公司、项目和团队等各种情况综合判断是否选择使用我，我是很有包容心的。 You can 上一篇：Typescript 为什么选择她 下一篇：Typescript 的成长环境 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"introduction/env.html":{"url":"introduction/env.html","title":"Typescript 的成长环境","keywords":"","body":"安装 说到如何使用我了，这个很简单，因为和安装其他 npm 包一样，请看 // 全局安装我 sudo npm install -g typescript 命令行输入 tsc -v 查看成功安装好我，然后就是你可以在任何地方执行 tsc 命令了。 开发工具首推 Visual Studio Code（没给我广告费） 我的精彩履历中就提过，我的一个优势是增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等，好用到不要不要的。 主流的编辑器都支持我，这里推荐 Visual Studio Code，一款开源、跨终端、轻量级编辑器，同时内置就支持我。 还有就是它本身也是用我编写。 下载安装：https://code.visualstudio.com/ 第一个例子 写个 hello.ts 来试试。 // hello.ts const hello = str => { return `Hello, ${str}`; } hello('typescript'); 输入 tsc hello.ts，你会看到和 hello.ts 同级目录多出一个 hello.js 文件 // hello.js var hello = function (str) { return \"Hello, \" + str; }; hello('typescript'); 加点语法 上面，也没看出和 javascript 有什么不同，不急，咱看 hello2.ts // hello2.ts const hello2 = (str: string) => { return `Hello, ${str}`; } hello2('typescript'); hello2(99); 这里，给参数 string 添加了 : string 类型注解，指定变量的类型为字符串，: 的前后有没有空格都可以。你会发现编辑器中会提示错误 然后执行 tsc hello2.ts，编译也会出错。说 99 不能作为类型需要是字符串的参数，这是我希望看到的，这波操作 666。但是 hello2.js 还是编译出来了生成 js 文件了（尽管 hello2.ts 书写有问题，但是前面说过我是有包容心的） // hello2.js var hello2 = function (str) { return \"Hello, \" + str; }; hello2('typescript'); hello2(99); 上述例子中，编译出来的 js 并没有什么检查的代码被插入进来，这是因为我只会进行静态检查，如果发现有错误，编译的时候就会报错（但是我还是生成编译结果）。 接下来 接下来，就要开始无聊的接口讲解、代码编写和示例测试。希望你能熬过这段艰难期（也希望你能打心底接受我-Typescript）。 本次代码 Github You can 上一篇：Typescript 精彩履历 下一篇：Typescript 基础类型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/":{"url":"basic/","title":"基础篇","keywords":"","body":"基础篇 Typescript 基础类型 Typescript 进阶类型 Typescript 类型推论 Typescript 类型断言 Typescript 联合类型 Typescript 对象类型-接口 Typescript 数组类型 Typescript 函数类型 Typescript 函数类型 Typescript 声明文件 Typescript 内置对象 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/basic.html":{"url":"basic/basic.html","title":"Typescript 基础类型","keywords":"","body":"基础类型是我自定义的，主要这章介绍的在 Javascript 中都有的类型。另外，也是区别于下章进阶类型（Javascript 没有或隐性的数据类型）。 基础知识脑补下 在 JavaScript 的类型分为两种： 原始数据类型（Primitive data types） 对象类型（Object types） 其中，原始数据类型包括：布尔值、数字、字符串、null、undefined 以及 ES6 中的新类型 Symbol。本章选择性讲前 5 种。 布尔值 它是最基础的数据类型，其值是 true/false。在 JavaScript 和 TypeScript 里都使用 boolean 来定义（其它语言中也一样）。 // boolean.ts let isDone: boolean = false; 编译（tsc boolean.ts）后 // boolean.js var isDone = false; 问：使用构造函数 Boolean 来创造可以么？比如 // boolean2.ts let isDoneByNewBoolean: boolean = new Boolean(1); 编译（编辑器里）前 编译后 问题在于 new Boolean(1) 返回的是一个对象。 再问：直接使用 Boolean(1) 怎样？ // boolean3.ts let isDoneByBoolean: boolean = Boolean(1); 编译后 // boolean3.js var isDoneByBoolean = Boolean(1); Boolean(1) 返回的是个布尔值。 数字 和 JavaScript 一样，TypeScript 里的所有数字都是浮点数，类型是 number。 // number.ts let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; // ES6 中的二进制表示法 let octalLiteral: number = 0o744; // ES6 中的八进制表示法 let notANumber: number = NaN; let infinityNumber: number = Infinity; 编译后 // number.ts var decLiteral = 6; var hexLiteral = 0xf00d; var binaryLiteral = 10; // ES6 中的二进制表示法 var octalLiteral = 484; // ES6 中的八进制表示法 var notANumber = NaN; var infinityNumber = Infinity; 字符串 和 JavaScript 一样，使用 string 表示文本数据类型，可以用双引号（\"）或单引号（'）表示字符串。 // string.ts let str: string = 'Typescript'; let say: string = `Hello, ${str}`; 编译后 // string.js var str = 'Typescript'; var say = \"Hello, \" + str; null 和 undefined 在 TypeScript 的世界里，null 和 undefined 可用自身来定义数据类型。不过其用处不大。 // null-undefined.ts let u: undefined = undefined; let n: null = null; 编译后 // null-undefined.js var u = undefined; var n = null; 问：那将值 null 和 undefined 换个位置会怎样呢？ // null-undefined2.ts let u: undefined = null; let n: null = undefined; 编译后 // null-undefined2.js var u = null; var n = undefined; 问：那像下面这样呢？ // null-undefined3.ts let nu: number = undefined; let nn: number = null; let su: string = undefined; let sn: string = null; let bu: boolean = undefined; let bn: boolean = null; 编译后 // null-undefined3.js var nu = undefined; var nn = null; var su = undefined; var sn = null; var bu = undefined; var bn = null; 从上面 3 个例子，可基本判断，null 和 undefined 是所有类型的子类型(可以把 null 和 undefined 赋值给 number 等所有类型的变量，也就是赋值没多大意义）。 空值 在 JavaScript 的世界里是没有空值的概念，但在 TypeScript 中，可以用 void 表示没有任何返回值的函数。 // void.ts function sayTs(): void { console.log('Hello, Typescript'); } function sayTs2(): void { return 'Hello, Typescript'; } 编译前 编译后 但还是编译出来了 // void.js function sayTs() { console.log('Hello, Typescript'); } function sayTs2() { return 'Hello, Typescript2'; } 问：void 与 null（或undefined）间关系如何？ // void2.ts let u: void = undefined; let n: void = null; 编译后 // void2.js var u = undefined; var n = null; 问：void 与 string(number、boolean)关系如何？ // void3.ts let n: void = 1; let b: void = false; let s: void = '1'; 编译前 编译后 但还是编译出来了 // void3.js var vn = 1; var vb = false; var vs = '1'; 总结下，只能将 undefined、null 和没有返回值的函数赋值给 void（空值）类型。 本次代码 Github You can 上一篇：Typescript 的成长环境 下一篇：Typescript 进阶类型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/advanced.html":{"url":"basic/advanced.html","title":"Typescript 进阶类型","keywords":"","body":"任意值 用来表示允许赋值为任意类型。 场景：在编程阶段还不清楚类型的变量指定一个类型。比如来自用户输入或第三方代码库，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么任意值就派上用场了。 // any.ts let notSure: any = 1; notSure = \"换成字符串了\"; notSure = false; 编译后 // any.js var notSure = 1; notSure = \"换成字符串了\"; notSure = false; 任意值还有属性和方法，一起看下 先看属性 // anyAttr.ts let anyAttr: any = 'typescript'; console.log(anyAttr.name); console.log(anyAttr.name.firstName); 编译后 // anyAttr.js var anyAttr = 'typescript'; console.log(anyAttr.name); console.log(anyAttr.name.firstName); 再看方法 // anyFn.ts let anyFn: any = 'typescript'; anyFn.setName('ts'); anyFn.name.setName('name'); 编译后 // anyFn.js var anyFn = 'typescript'; anyFn.setName('ts'); anyFn.name.setName('name'); 可推断，声明一个变量为任意值之后，对它的任何操作（属性和方法），返回的内容的类型都是任意值（就这么无限下去）。 问（猜）：那指定了类型是 any 和什么类型都不指定是不是一个意思？ // anyNothing.ts let anyNothing: any; anyNothing = 'pr'; anyNothing = 30; let anyNothing1; anyNothing1 = '江湖再见'; anyNothing1 = 18; 编译后 // anyNothing.js var anyNothing; anyNothing = 'pr'; anyNothing = 30; var anyNothing1; anyNothing1 = '江湖再见'; anyNothing1 = 18; 下个粗鲁的结论，就是一样的(变量在声明时未指定其类型，那就默认指定为任意值类型)。 Never 表示永不存在的值的类型。使用场景有 抛出异常; 不会有返回值的函数表达式或箭头函数表达式的返回值类型; 变量; // never.ts // 返回 never 的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为 never function fail() { return error(\"有错\"); } // 返回 never 的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { // doSomething } } function log(): never { console.log('日志') } function ok(): never { return '一切正常'; } 编译前 编译后 但还是编译出来了 // never.js // 返回 never 的函数必须存在无法达到的终点 function error(message) { throw new Error(message); } // 推断的返回值类型为 never function fail() { return error(\"有错\"); } // 返回 never 的函数必须存在无法达到的终点 function infiniteLoop() { while (true) { // doSomething } } function log() { console.log('日志'); } function ok() { return '一切正常'; } Object 表示非原始类型（也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型）。 那下面例子说明，在使用 object 的时候，可以理解为 Object.createObj 这样使用。 // object.ts declare function createObj(o: object): void; createObj({ name: \"typescript\" }); createObj(undefined); createObj(null); createObj('ts'); createObj(30); createObj(false); 编译前 编译后 但还是编译出来了 // object.js createObj({ name: \"typescript\" }); createObj(undefined); createObj(null); createObj('ts'); createObj(30); createObj(false); 注：关键字 declare 是用来声明变量，在这里只是一个辅助，后面会有对它做详细说明。 经过测试，null 和 { name: \"typescript\" } 是对象，所以没有什么问题，undefind 也没问题，我的理解是它是任何类型的子类型（当然也是 object 的子类型）。至于剩下的 3 个有问题已经很明显了。 补充说明 本想将数组类型和函数类型放在这里的，但考虑到以下两点，所以会单独整理成 2 篇内容。 会使得本篇篇幅过长； 数组类型和函数类型介绍时会牵扯其他概念，所以所牵扯到的概念会在这两篇内容前介绍； 不知正在阅读的你是否赞同我的这种思路和书写方式？请留言... 本次代码 Github You can 上一篇：Typescript 基础类型 下一篇：Typescript 类型推论 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/inference.html":{"url":"basic/inference.html","title":"Typescript 类型推论","keywords":"","body":" 说明：基于已经有一定基础了，接下来 1.展示编译错误的结果会根据情况通过继续截图或贴在代码的后面； 2.本章节及之后章节会以版本号递增方式来记录学习过程，之前是时间（年-月-日）的方式； 3.加点工程化的东西，这个会逐渐优化，便于将精力专注于所学习内容上; 4.对于提高学习效率这块，如果你有更好的思路或方法，还请在评论区分享下，帮助他人和我一起进步； 创建 package.json（notes 目录下） npm init -y // notes/package.json { \"name\": \"notes\", \"version\": \"0.0.4\", \"description\": \"辅助学习typescript\", \"main\": \"index.js\", \"scripts\": { \"build\": \"tsc --outDir $npm_package_version/build $npm_package_version/*.ts\", \"watch\": \"tsc -w $npm_package_version/*.ts\", \"createDir\": \"mkdir $npm_package_version\" }, \"keywords\": [], \"author\": \"ruizhengyun (https://github.com/ruizhengyun)\", \"license\": \"MIT\" } 新版本开始编写文章前，只需将 version 递增下即可; 操作完上一步，命令行输入 npm run createDir 来创建这个版本的示例文件夹; 输入 npm run build 可以实时监听当前版本目录下的 *.ts 文件并将其编译到当前版本 build 文件目录下（这里有个小问题就是之后新增文件不能监控到，你的重启下服务）; 要是没有明确的指定类型，那么 TS 会推断出一个类型，这是依照类型推论（Type Inference）的规则来的。 看个简单例子 // inference.ts let inference = 'ts'; inference = 18; // 0.0.4/inference.ts:2:1 - error TS2322: Type '18' is not assignable to type 'string'. // 2 inference = 18; 有人问了，这段代码写法上没有任何问题啊？为什么有错？ 不好意思，现在你在 TS 的世界里，就得按照这里的规则来。既然来学 TS，咱就得放下包袱（以往一些经验）。 出现这问题的原因在于TS 在变量没有明确指定类型的情况下会推测出一个类型（类型推论）。 可以通过下面这种方式来理解上面的写法 // inference.ts let inference: string = 'ts'; inference = 18; // 0.0.4/inference.ts:2:1 - error TS2322: Type '18' is not assignable to type 'string'. // 2 inference = 18; 举一反三 刚刚在定义的时候就赋值了，那如果一开始就不定义。之前的经验告诉我们，类型是 any，那后面赋值字符串，然后再赋值数字都可以咯。Have a try ~ // inference2.ts let inference2; inference2 = 'ts'; inference2 = 18; 编译后 // build/inference2.js var inference2; inference2 = 'ts'; inference2 = 18; 本次代码 Github You can 上一篇：Typescript 进阶类型 下一篇：Typescript 联合类型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/union.html":{"url":"basic/union.html","title":"Typescript 联合类型","keywords":"","body":"简单例子 联合类型（Union Types），其取值可以为多种类型中的一种，前提是取值的类型之前定义过。 // union.ts let stringAndNumber: string | number; stringAndNumber = 'ts'; stringAndNumber = 7; 编译后 // build/union.js var stringAndNumber; stringAndNumber = 'ts'; stringAndNumber = 7; 可见，联合类型使用 | 来分隔每种类型。 属性和方法 // unionGetLength.ts const unionGetLength = (something: string | number): number => { return something.length; } // 0.0.4/unionGetLength.ts:2:22 - error TS2339: Property 'length' does not exist on type 'string | number'. // Property 'length' does not exist on type 'number'. // 2 return something.length; 问题在于 number 类型没有 length 属性。 举一反三：换个共有的属性 toString() 试试 // unionToString.ts const unionToString = (something: string | number): string => { return something.toString(); } 编译后 // build/unionToString.js var unionToString = function (something) { return something.toString(); }; 与类型推论的使用 // unionInference.ts let unionInference: string | number; unionInference = 'ts'; console.log('unionInference string length: ', unionInference.length); unionInference = 18; // 永远活在那 18 岁 console.log('unionInference number length: ', unionInference.length); // 0.0.4/unionInference.ts:6:62 - error TS2339: Property 'length' does not exist on type 'number'. // 6 console.log('unionInference number length: ', unionInference.length); 上面例子中，第 2 行（基于这个文件 unionInference.ts）unionInference （因为 ts）被推断为 string，所以访问 length 属性没有问题；同理，第 6 行（因为 18）被推断为 number，访问 length 自然就报错了。 本次代码 Github You can 上一篇：Typescript 类型推论 下一篇：Typescript 类型断言 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/assertion.html":{"url":"basic/assertion.html","title":"Typescript 类型断言","keywords":"","body":"类型断言（Type Assertion）就是手动指定一个值的类型。具体看看怎么做吧 招式一和招式二 // 招式一 值 // 招式二 值 as 类型 推荐使用这种，因为在 tsx 语法中只认它。而 tsx 是 react 的 jsx 语法的 ts 版，后面实战篇幅天天见，别着急。 拿上篇联合类型例子作教材 // unionGetLength.ts const unionGetLength = (something: string | number): number => { return something.length; } // 0.0.4/unionGetLength.ts:2:22 - error TS2339: Property 'length' does not exist on type 'string | number'. // Property 'length' does not exist on type 'number'. // 2 return something.length; 于是想：如果有 length 属性就返回 something.length, 没有就转为字符串然后再返回 something.length 可不可以呢？ // unionGetLength2.ts const unionGetLength2 = (something: string | number): number => { if(something.length){ return something.length; } else { return something.toString().length; } } // 0.0.4/unionGetLength2.ts:3:26 - error TS2339: Property 'length' does not exist on type 'string | number'. // Property 'length' does not exist on type 'number'. // 3 return something.length; 猜想失败，unionGetLength2.ts 与 unionGetLength.ts 还是一样的问题。然而到这里我们再往前进一步（就是加上类型断言），如 // assertionGetLength.ts const assertionGetLength = (something: string | number): number => { if((something as string).length){ return (something as string).length; } else { return something.toString().length; } } // 或 const assertionGetLengthOther = (something: string | number): number => { if((something).length){ return (something).length; } else { return something.toString().length; } } 编译后 // assertionGetLength.js var assertionGetLength = function (something) { if (something.length) { return something.length; } else { return something.toString().length; } }; // 或 var assertionGetLengthOther = function (something) { if (something.length) { return something.length; } else { return something.toString().length; } }; 总结：类型断言的用法就是将断言的变量 xx 改为 (xx as Type) 或 (xx)。 思维发散 上篇联合类型的例子中，类型定义为 string | number，如果类型断言不是两者中其一会怎样？ // assertionGetLength2.ts const assertionGetLength2 = (something: string | number): boolean => { return (something as boolean); } const assertionGetLength21 = (something: string | boolean): string => { return (something as string); } const assertionGetLength22 = (something: string | boolean): boolean => { return (something as boolean); } const assertionGetLength23 = (something: string | boolean): number => { return (something as number); } // 0.0.4/assertionGetLength2.ts:2:13 - error TS2352: Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. // Type 'number' is not comparable to type 'boolean'. // 2 return (something as boolean); // 0.0.4/assertionGetLength2.ts:14:13 - error TS2352: Conversion of type 'string | boolean' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. // Type 'true' is not comparable to type 'number'. // 14 return (something as number); 可见，类型断言必须联合类型中的一种，类型断言只是做类型选择，而不是做类型转换。 本次代码 Github You can 上一篇：Typescript 联合类型 下一篇：Typescript 对象类型-接口 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/object_interfaces.html":{"url":"basic/object_interfaces.html","title":"Typescript 对象类型-接口","keywords":"","body":"新的一天，打卡签到。按照在 Typescript 类型推论 里的约定，我们将文件 notes/package.json 的 version 改为 0.0.5，然后 npm run createDir, 这个时候，notes 目录下就会新增文件夹 0.0.5，很简单是吧，后面章节，就忽略这些简单操作了，直接奔主题。 在学之前，自以为对象类型是用 object 来定义，其实不然，在 Typescript 的玩法里，是用接口（Interfaces）来定义。 玩法（介绍接口） 面向对象语言中，接口（Interfaces）是对行为的抽象（可以用事物的本质来辅助理解）。而具体如何行动由类（class）来实现（implement）（可以用事物的现象来辅助理解）。 上代码（举例子） // interfaces.ts interface Person { name: string; age: number; } let pr: Person = { name: '胖芮', age: 30 } 根据玩法，上面例子中定义了一个接口 Person（行为的抽象，事物的本质），接着定义了一个变量 pr，其类型就是 Person（接口是类型，对象类型）。约束了定义的变量 pr 属性类型必须和接口 Person 一致。 通常，接口首字母大写（这个可以用 react 组件名称命令规则来辅助理解）。 问：定义变量的属性个数比接口少可以么？多一个行不？ // interfaces2.ts interface Person2 { name: string; age: number; } let pr2: Person2 = { name: '胖芮' } // 0.0.5/interfaces2.ts:6:5 - error TS2741: Property 'age' is missing in type '{ name: string; }' but required in type 'Person2'. // 6 let pr2: Person2 = { // 0.0.5/interfaces2.ts:3:5 // 3 age: number; // 'age' is declared here. // interfaces3.ts interface Person3 { name: string; age: number; } let pr3: Person3 = { name: '胖芮', age: 30, address: '杭州' } // 0.0.5/interfaces3.ts:9:5 - error TS2322: Type '{ name: string; age: number; address: string; }' is not assignable to type 'Person3'. // Object literal may only specify known properties, and 'address' does not exist in type 'Person3'. // 9 address: '杭州' 可见，赋值的时候，多一个少一个都不行，变量的属性必须和接口的属性保持一致（前提对接口属性没做处理）。 可选属性 上面在对接口属性没做任何处理的情况下，赋值的时候，变量属性不能多也不能少。可是有时候我们还是希望有些属性是可选的，一起来看看 // interfaces4.ts interface Person4 { name: string; age?: number; } let pr4: Person4 = { name: '胖芮' } let pr4_1: Person4 = { name: '胖芮', address: '杭州' } // 0.0.5/interfaces4.ts:12:5 - error TS2322: Type '{ name: string; address: string; }' is not assignable to type 'Person4'. // Object literal may only specify known properties, and 'address' does not exist in type 'Person4'. // 12 address: '杭州' 可选属性是在属性后面加上 ?，这个很容易理解（结合正则）。而对于多余属性仍然会报错（不能睁只眼闭只眼，多么正直啊）。 任意属性 难道就没别的办法了，看看下面 // interfaces5.ts interface Person5 { name: string; age?: number; [propName: string]: any; } let pr5: Person5 = { name: '胖芮', isMan: true, address: '杭州' } 编译后 // build/interfaces5.js var pr5 = { name: '胖芮', isMan: true, address: '杭州' }; 真是天无绝人之路，Typescript 我爱你，你还是挺有人情味的嘛。 [propName: string] 定义了任意属性，属性 key 类型为 string; 此时任意属性的类型我们设为 any，所以 isMan 和 address 都能通过； 思考：慢着慢着，任意属性如果设为 string，可选属性设为 number，两者有冲突么？ // interfaces6.ts interface Person6 { name: string; age?: number; [propName: string]: string; } let pr6: Person6 = { name: '胖芮', age: 30, address: '杭州' } // 0.0.5/interfaces6.ts:3:5 - error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'. // 3 age?: number; // 0.0.5/interfaces6.ts:7:5 - error TS2322: Type '{ name: string; age: number; address: string; }' is not assignable to type 'Person6'. // Property 'age' is incompatible with index signature. // Type 'number' is not assignable to type 'string'. // 7 let pr6: Person6 = { // 0.0.5/interfaces6.ts:15:5 - error TS2322: Type 'string' is not assignable to type 'number'. // 15 age: '30', // 0.0.5/interfaces6.ts:3:5 // 3 age?: number; // The expected type comes from property 'age' which is declared here on type 'Person6' 从上面例子的报错及报错原因中，我们明白 age 赋值既不能为数字也不能为字符串（到底闹哪样，让不让人活了）； age 的 number 类型不是任意属性的 string 的子集，所以 age 怎么赋值都不对； 所以，我们可以将任意属性改为 any。还有一种解决方式，只不过意义不大。 // interfaces7.ts interface Person7 { name: string; age?: number | string; [propName: string]: string | number; } let pr7: Person7 = { name: '胖芮', age: 30, address: '杭州' } let pr7_1: Person7 = { name: '胖芮', age: '30', address: '杭州' } 编译通过，通过变量的赋值，age 可为数字也可为字符串，那我们用联合类型 number | string，这里调整了，那任意属性也得调整，也至少得是 string | number，当然为 any 最好不过。 只读属性 说完了可选属性和任意属性，再看看另外一种场景只读属性。其使用场景是对象的某些字段只在创建时被赋值，后面不可更改。 // interfaces8.ts interface Person8 { readonly name: string; age?: number | string; [propName: string]: any; } let pr8: Person8 = { name: '胖芮', age: 30, address: '杭州' } pr8.age = 18; // 永远18岁 pr8.name = '胖芮2代'; // 火影看多了 let pr8_1: Person8 = { address: '杭州' } pr8_1.age = 18; pr8_1.name = '胖芮3代'; // 0.0.5/interfaces8.ts:14:5 - error TS2540: Cannot assign to 'name' because it is a read-only property. // 14 pr8.name = '胖芮2代'; // 火影看多了 // 0.0.5/interfaces8.ts:17:5 - error TS2741: Property 'name' is missing in type '{ address: string; }' but required in type 'Person8'. // 17 let pr8_1: Person8 = { // 0.0.5/interfaces8.ts:2:14 // 2 readonly name: string; // 'name' is declared here. // 0.0.5/interfaces8.ts:22:7 - error TS2540: Cannot assign to 'name' because it is a read-only property. // 22 pr8_1.name = '胖芮3代'; 上面例子中，我们可看出 接口定义时，我们在 name 属性前加了关键字 readonly，意指该属性只读； 变量赋值后，给变量的 age 和 name 重新赋值，给 name 赋值这行报错，这是我们希望看到的，666; 对变量 pr8_1 赋值时，可读属性 name 没有被赋值（这个错误我们容易理解），后面才给 name 赋值，又报错，因为是它是可读属性，哪怕之前给变量赋值时没给它赋值; 可见，对只读属性的约束是第一次给只读属性的对象赋值，而不是第一次给只读属性赋值。 本次代码 Github You can 上一篇：Typescript 类型断言 下一篇：Typescript 数组类型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/array.html":{"url":"basic/array.html","title":"Typescript 数组类型","keywords":"","body":"数组类型定义方式有多种，可见灵活性很强，一起来看看吧。 招式一和招式二 // 招式一 类型[] // 招式二：泛型 Array 用熟悉的斐波那契数列（Fibonacci sequence）举例 // arrayFibonacci.ts let arrayFibonacci: number[] = [1, 1, 2, 3, 5, 8]; 问：上面赋值的数组中有多种类型会怎样？ // arrayFibonacci2.ts let arrayFibonacci2: number[] = [1, 1, '2', false, 5, 8]; // array.ts:1:5 - error TS2322: Type '(string | number | boolean)[]' is not assignable to type 'number'. 错误 ❌ 原因在于 '2', false 是不能分配给纯数字类型，要想兼容得用联合类型（错误提示中已给出）？ // arrayFibonacci3.ts let arrayFibonacci3: (number | string | boolean)[] = [1, 1, '2', false, 5, 8]; 问：给数组定义数字类型，我们知道数组有很多方法，那 push 一个字符串行不行？ // arrayPush.ts let arrayPush: Array = [1, 2, 3]; arrayPush.push(5); arrayPush.push('1'); // 0.0.5/arrayPush.ts:3:16 - error TS2345: Argument of type '\"1\"' is not assignable to parameter of type 'number'. // 3 arrayPush.push('1'); 看来，必须的传入数字。 招式三：接口 // arrayInterface.ts interface ArrayNumber { [index: number]: number } let arrayNumberInterface: ArrayNumber = [1, 1, 2, 3, 5]; 上面的例子所要表达的是，只要 index 的类型是 number，那么值的类型必须是 number。 问：如果数组中想要存放多种类型怎么办？ // arrayAny.ts let arrayAny: any[] = [1, '1', false, { name: 'ts' }, [1, 1, 2]]; // 或 let arrayAny2: Array = [1, '1', false, { name: 'ts' }, [1, 1, 2]]; 问：对于类数组怎么处理？ 不就是在赋值时给变量加上 : Type[] 嘛，可以试下 // arrayArguments.ts function arrayArguments(){ let args: number[] = arguments; let args2: Array = arguments; } // 0.0.5/arrayArguments.ts:2:9 - error TS2740: Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more. // 2 let args: number[] = arguments; // 0.0.5/arrayArguments.ts:3:9 - error TS2322: Type 'IArguments' is not assignable to type 'number[]'. // 3 let args2: Array = arguments; 看来类数组不是像上面想的那么简单，还需要专门的类型 IArguments 来定义，IArguments 是内置对象，这个下篇单独说说它。 // arrayArguments2.ts function arrayArguments2(){ let args: IArguments = arguments; } 本次代码 Github You can 上一篇：Typescript 对象类型-接口 下一篇：Typescript 函数类型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/function.html":{"url":"basic/function.html","title":"Typescript 函数类型","keywords":"","body":"函数，一等公民（满满的自豪感）。 招式一：函数声明（function declaration） // function.ts function sum(x: number, y: number): number { return x + y; } 通过对接口定义的认识，函数的参数多一个和少一个（没有对参数做可选操作）应该也不行。试一下 // function2.ts function sum2(x: number, y: number): number { return x + y; } sum2(1, 2); sum2(1, 2, 3); sum2(1); // 0.0.6/function2.ts:7:12 - error TS2554: Expected 2 arguments, but got 3. // 7 sum2(1, 2, 3); // 0.0.6/function2.ts:9:1 - error TS2554: Expected 2 arguments, but got 1. // 9 sum2(1); // 0.0.6/function2.ts:1:26 // 1 function sum2(x: number, y: number): number { // An argument for 'y' was not provided. 提示很明显了，就是说我们参数多了一个，参数少了一个。总结，函数对于参数的个数是不容修改的。 招式二：函数表达式（function expression） // function3.ts const sum3 = function(x: number, y: number): number { return x + y; } 从函数表达式的结构分析，= 右边（→_→）大家都懂的，但是👈左边我们发现有点空，是不是得有个类型定义下呢？那又该如何定义？ // function4.ts const sum4: (x: number, y: number) => number = function(x: number, y: number): number { return x + y; } 来看 = 左边，多了 : (x: number, y: number) => number，这里的 => 不是我们熟悉的 ES6 箭头函数中的 =>。Typescript 中的 => 是用来定义函数的，函数左边是是输入类型（用 () 括起来），右侧是输出类型。其实，多出的内容也可以不用手动添加的（晦涩难懂），因为通过赋值操作也可以将类型推论出来（有种若不自宫亦可成功的意味，哈哈）。 招式三：接口定义（interfaces） // function5.ts interface Function5 { (x: string, y: string): boolean } let function5: Function5 = (x: string, y: string) => { return x.search(y) > -1; } 上面例子是用接口的形式来加持 ES6 的箭头函数，棒棒的。 可选参数 这个和上篇接口类型一样的方式 // function6.ts const showMyName = (firstName: string, lastName?: string): string => { if(lastName) { return `${firstName}${lastName}`; } else { return firstName; } } console.log(showMyName('pr')); console.log(showMyName('江湖', '再见')); 编译后 // function6.js var showMyName = function (firstName, lastName) { if (lastName) { return \"\" + firstName + lastName; } else { return firstName; } }; console.log(showMyName('pr')); console.log(showMyName('江湖', '再见')); 问：可选参数后面还能加参数（必选参数）么？ // function7.ts const showMyName7 = (firstName?: string, lastName: string): string => { if(firstName) { return `${firstName}${lastName}`; } else { return lastName; } } // 0.0.6/function7.ts:1:42 - error TS1016: A required parameter cannot follow an optional parameter. // 1 const showMyName7 = (firstName?: string, lastName: string): string => { 报错的原因是可选参数后面不能再放参数（必选）。 剩余参数 我们知道 ES6 有 rest 参数（形式是 ...rest ）, 用于获取函数的多余参数，这样就不需要使用arguments对象了。那 Typescript 中的 rest 是否也是如此呢？ // function8.ts // function8.ts const push = (array: any[], ...rest: any[]) => { rest.forEach(r => { array.push(r); }); } let arr = [false]; push(arr, '1', 2, 3); const push1 = (array: any[], ...rest: any[], x: number) => { rest.forEach(r => { array.push(r); }); rest.push(x); } // 0.0.6/function8.ts:11:30 - error TS1014: A rest parameter must be last in a parameter list. // 11 const push1 = (array: any[], ...rest: any[], x: number) => { 参数 array 和 ..rest 我们都定义了类型，...rest 其实就是一个数组。另外，剩余参数和可选参数后面都不能再有参数。 默认值 ES6 中有给函数参数添加默认值的操作，那 Typescript 如果也有此等操作，那是怎样的？设置默认值的参数可以再有参数么（是不是被不能再有参数吓怕了）？ // function9.ts const showMyNameAgain = (firstName: string = 'pr', lastName?: string, ...rest: any[]): string => { let tmp: string = ''; if(rest.length) { tmp = rest.join(' '); } if(lastName) { return `${firstName}${lastName}${tmp}`; } else { return `${firstName}${tmp}`; } } console.log(showMyNameAgain()); console.log(showMyNameAgain('胖芮','，男', '今年', 30)); 编译后 // function9.js var showMyNameAgain = function (firstName, lastName) { if (firstName === void 0) { firstName = 'pr'; } var rest = []; for (var _i = 2; _i 通过上面例子可见，默认值与 ES6 赋值方式无异。同时，我们发现剩余参数可放在可选参数后。 重载 重载的意思不是重新载入，这儿不可望文生义。实际意思是根据不同数量或类型的参数，做出不同的处理。 比如有这个一个场景：传入数字就乘以10并返回数字，传入字符串就在它前面加上 hello并返回字符串。 我们先分析下注意点 输出值类型需同输入参数类型一致（用到联合类型）； 根据参数类型做不同操作处理（用到类型判断）； // function10.ts const chongzai = (x: number | string): number | string => { if(typeof x === 'string') { return `hello, ${x}`; } else if (typeof x === 'number') { return x * 10; } } 以上例子这么写没有问题，可是，有一点似乎没严格约束就是第一点（输出值类型需同输入参数类型一致（用到联合类型）），上面代码 return x * 10; 改为 x * 10 + ''; 也不会报错，但是并不符合我们的要求。所以得手动给函数定义类型 // function11.ts function chongzai2(x: string): string; function chongzai2(x: number): number; function chongzai2(x: number | string): number | string { if(typeof x === 'string') { return `hello, ${x}`; } else if (typeof x === 'number') { return x * 10; } } 咋一看，怎么函数 chongzai2 声明了 3 次。其实不然，前 2 次是函数定义，第 3 次是函数实现。 本次代码 Github You can 上一篇：Typescript 数组类型 下一篇：Typescript 内置对象 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"basic/built_in_objects.html":{"url":"basic/built_in_objects.html","title":"Typescript 内置对象","keywords":"","body":"在 Typescript 数组类型 这篇文章末我们提及到了 Typescripe 一种内置对象。 在 Typescript 中内置对象是作为已经定义好（内置）的类型去使用的，很显然它是存在全局作用域（Global）上。 ECMAScript 内置对象 拿 Boolean 这个内置对象来说吧，这样的对象在 ECMAScript 中有很多。 // buildInObjects.ts let b1: boolean = new Boolean(1); let b2: Boolean = new Boolean(1); // 0.0.7/buildInObjects.ts:1:5 - error TS2322: Type 'Boolean' is not assignable to type 'boolean'. // 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible. // 1 let b1: boolean = new Boolean(1); 第 1 行报错，我们在 Typescript 基础类型 就分析过了，不能将 Boolean 分配给 boolean，前者是包装器对象，后者是基本类型。这也间接说明第 2 行能正常运行的原因了。 DOM 与 BOM 内置对象 // buildInObjects2.ts const body: HTMLElement = document.body; const divList: NodeList = document.querySelectorAll('div'); document.addEventListener('click', (e: MouseEvent) => { // do something }); 示例中 HTMLElement、NodeList 和 MouseEvent 就是 DOM 与 BOM 内置对象。 总结：不管 ECMAScript 内置对象还是 DOM 与 BOM 的内置对象，其文件定义在 [TypeScript 核心库的文件][] 中。下面就说说它。 在 Node.js 中应用 是不是也内置了呀？这个，这个不是了。你得引入第三方声明文件。这里牵扯到声明文件，下一篇内容我们来说说。 npm install @types/node --save-dev TypeScript 核心库的文件 它定义了浏览器环境所有类型，预置在 Typescript 中，所以我们能随手拿来用。而这些文件都帮我们做了很多判断工作了（一个字省心）。 // buildInObjects3.ts Math.pow(10, '3'); // 0.0.7/buildInObjects3.ts:1:14 - error TS2345: Argument of type '\"3\"' is not assignable to parameter of type 'number'. // 1 Math.pow(10, '3'); 通过错误提示我们可以推断出 Math.pow 是这么定义的 // buildInObjects4.ts interface Math { pow(x:number, y:number): number; join(x:string, y:string): string; } Math.join('1', '2'); Math.join('1', 2); // 0.0.7/buildInObjects4.ts:7:16 - error TS2345: Argument of type '2' is not assignable to parameter of type 'string'. // 7 Math.join('1', 2); 在推断 Math.pow 类型定义的同时，顺便造了一个 Math.join，其输入类型和输出类型都是字符串，随后调用这个方法时参数传了数字类型，因而同 Math.pow(10, '3') 错误类似。 本次代码 Github You can 上一篇：Typescript 函数类型 下一篇：Typescript 声明文件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/":{"url":"advanced/","title":"进阶","keywords":"","body":"进阶篇 Typescript 元祖 Typescript 枚举 Typescript 类 Typescript 类与接口 Typescript 别名和字符串 Typescript 泛型 Typescript 声明文件 Typescript 声明合并 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/tuple.html":{"url":"advanced/tuple.html","title":"Typescript 元祖","keywords":"","body":"元祖与数组结构上类似，待会你就知道了。 举个例子 // tuple.ts let tuple: [string, number]; tuple = ['pr', 30]; let tuple1_1: [string, number] = ['pr', 30]; let tuple1_2: [string, number] = ['pr']; let tuple1_3: [string, number]; tuple1_3 = ['pr', 30, 18]; // 0.0.8/tuple.ts:6:5 - error TS2741: Property '1' is missing in type '[string]' but required in type '[string, number]'. // 6 let tuple1_2: [string, number] = ['pr']; // 0.0.8/tuple.ts:9:1 - error TS2322: Type '[string, number, number]' is not assignable to type '[string, number]'. // Types of property 'length' are incompatible. // Type '3' is not assignable to type '2'. // 9 tuple1_3 = ['pr', 30, 18]; 通过例子，可以发现直接对变量类型定义并赋值的时候，不能多也不能少（挺熟悉的吧） 问：多传肯定是不可能的了，如果少传可以么？ 本文开篇我们不是说元祖和数组结构类似么，试下下标赋值 // tuple2.ts let tuple2: [string, number]; tuple2[0] = 'pr'; let tuple2_1: [string, number]; tuple2_1[1] = 30; 这波操作 666。 新增元素 // tuple3.ts let tuple3: [string, number] = ['pr', 30]; tuple3.push(18); tuple3.push('pr 18'); tuple3.pop(); tuple3.unshift('pr is a jser'); tuple3.unshift(null); tuple3.unshift(undefined); tuple3.unshift(false); // 0.0.8/tuple3.ts:10:16 - error TS2345: Argument of type 'false' is not assignable to parameter of type 'string | number'. // 10 tuple3.unshift(false); 可以发现，添加元素的类型只能是 string | number（添加 false 报错了），下个定论元祖添加元素的类型只能是元祖类型的联合类型。 本次代码 Github You can 上一篇：Typescript 内置对象 下一篇：Typescript 枚举 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/enum.html":{"url":"advanced/enum.html","title":"Typescript 枚举","keywords":"","body":"枚举标志性动作是使用关键字 enum 来定义类型。比如 // enum.ts enum Friends {张三, 李四, 王五}; // enum2.ts enum Friends2 {张三, 李四, 王五}; console.log(Friends2[0] === '张三') console.log(Friends2['张三'] === 0) 编译后 // enum2.js var Friends2; (function (Friends2) { Friends2[Friends2[\"\\u5F20\\u4E09\"] = 0] = \"\\u5F20\\u4E09\"; Friends2[Friends2[\"\\u674E\\u56DB\"] = 1] = \"\\u674E\\u56DB\"; Friends2[Friends2[\"\\u738B\\u4E94\"] = 2] = \"\\u738B\\u4E94\"; })(Friends2 || (Friends2 = {})); ; console.log(Friends2[0] === '张三'); // true console.log(Friends2['张三'] === 0); // true 可见，枚举可以可用下标索引获取值，另外枚举的 key 和 value 可反向映射。 手动赋值 // enum3.ts enum Friends3 { 张三 = 30, 李四 = 18, 王五 }; console.log(Friends3['张三'] === 30); console.log(Friends3['李四'] === 18); console.log(Friends3['王五'] === 19); enum Friends3_1 { 张三 = '30', 李四 = '18', 王五 = '9' }; enum Friends3_2 { 张三 = '30', 李四 = '18', 王五 = 9 }; enum Friends3_3 { 张三 = '30', 李四, 王五 }; // 0.0.8/enum3.ts:8:30 - error TS1061: Enum member must have initializer. // 8 enum Friends3_3 { 张三 = '30', 李四, 王五 }; ~~ // 0.0.8/enum3.ts:8:34 - error TS1061: Enum member must have initializer. // 8 enum Friends3_3 { 张三 = '30', 李四, 王五 }; 编译后 // enum3.js var Friends3; (function (Friends3) { Friends3[Friends3[\"\\u5F20\\u4E09\"] = 30] = \"\\u5F20\\u4E09\"; Friends3[Friends3[\"\\u674E\\u56DB\"] = 18] = \"\\u674E\\u56DB\"; Friends3[Friends3[\"\\u738B\\u4E94\"] = 19] = \"\\u738B\\u4E94\"; })(Friends3 || (Friends3 = {})); ; console.log(Friends3['张三'] === 30); console.log(Friends3['李四'] === 18); console.log(Friends3['王五'] === 19); var Friends3_1; (function (Friends3_1) { Friends3_1[\"\\u5F20\\u4E09\"] = \"30\"; Friends3_1[\"\\u674E\\u56DB\"] = \"18\"; Friends3_1[\"\\u738B\\u4E94\"] = \"9\"; })(Friends3_1 || (Friends3_1 = {})); ; var Friends3_2; (function (Friends3_2) { Friends3_2[\"\\u5F20\\u4E09\"] = \"30\"; Friends3_2[\"\\u674E\\u56DB\"] = \"18\"; Friends3_2[Friends3_2[\"\\u738B\\u4E94\"] = 9] = \"\\u738B\\u4E94\"; })(Friends3_2 || (Friends3_2 = {})); ; var Friends3_3; (function (Friends3_3) { Friends3_3[\"\\u5F20\\u4E09\"] = \"30\"; Friends3_3[Friends3_3[\"\\u674E\\u56DB\"] = void 0] = \"\\u674E\\u56DB\"; Friends3_3[Friends3_3[\"\\u738B\\u4E94\"] = void 0] = \"\\u738B\\u4E94\"; })(Friends3_3 || (Friends3_3 = {})); ; 说一下 赋值是数字，可以部分赋值； 赋值中有一个是字符串，得所有成员都赋值； 问：如果值手动赋值一个字符串怎么办？ // enum4.ts enum Friends4 { 张三 = '30', 李四, 王五 }; enum Friends4_1 { 张三 = '30', 李四, 王五 }; enum Friends4_2 { 张三, 李四 = '30', 王五 }; enum Friends4_3 { 张三, 李四 = '30', 王五 = '30' }; enum Friends4_4 { 张三, 李四, 王五 = '30' }; enum Friends4_5 { 张三, 李四 = '30', 王五 = '30' }; enum Friends4_6 { 张三, 李四 = '30', 王五 = 30 }; // 0.0.8/enum4.ts:1:28 - error TS1061: Enum member must have initializer. // 1 enum Friends4 { 张三 = '30', 李四, 王五 }; // 0.0.8/enum4.ts:1:32 - error TS1061: Enum member must have initializer. // 1 enum Friends4 { 张三 = '30', 李四, 王五 }; ~~ // 0.0.8/enum4.ts:2:35 - error TS1061: Enum member must have initializer. // 2 enum Friends4_1 { 张三 = '30', 李四, 王五 }; // 0.0.8/enum4.ts:2:39 - error TS1061: Enum member must have initializer. // 2 enum Friends4_1 { 张三 = '30', 李四, 王五 }; ~~ // 0.0.8/enum4.ts:3:39 - error TS1061: Enum member must have initializer. // 3 enum Friends4_2 { 张三, 李四 = '30', 王五 }; ~~ // 0.0.8/enum4.ts:4:28 - error TS2553: Computed values are not permitted in an enum with string valued members. // 4 enum Friends4_3 { 张三, 李四 = '30', 王五 = '30' }; 上面，例子说明下 第 1 行报错，是因为只给第一个成员赋值字符串，其他成员没有赋值; 第 2-3 行报错，是因为类型断言 后面还有成员赋值; 第 4 行报错，是因为类型断言 后面赋值不是数字; 剩余几行没报错，是因为类型断言 后面的成员都赋值了（而且）; 总结 赋值是字符串，得全部都赋值； 赋值部分为字符串，得用类型断言，类型断言后面不能有赋值为字符串的成员； 本次代码 Github You can 上一篇：Typescript 元祖 下一篇：Typescript 类 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/class.html":{"url":"advanced/class.html","title":"Typescript 类","keywords":"","body":"ECMAScript 往事 在 ES6 之前是没有类这个概念的，都是通过构造函数来实现同等效果的，继承的实现通过原型链。 Typescript 除了实现 ES6 类 class 的功能外还有其他特性。一起看看。 概念串讲扫盲 类（class），定义事物的抽象特性（属性和方法）； 抽象类（Abstract class），可以让其他类继承的基类（不允许实例化），抽象方法必须在子类中实现； 接口（interface）：不同类公有属性或方法，可抽象成一个接口，接口可以被类实现（implements）。类的继承只能是一个，但可以被实现多次； 存取器（setter and getter）：属性的赋值与读取； 修饰符（modifiers）：是一些关键字，限定成员或类型的性质（public、protect、private）,Typescript 支持； 对象（object），类的实例，通过 new 生成实现； 面向对象（OOP）特性：封装、继承和多态； 封装（encapsulation）：将对数据属性的处理细节隐藏起来，对外只暴露接口。外部调用不需要知道细节，就能访问该对象，这也保证了外部无法改变内部数据属性； 继承（inheritance）：子类继承父类，子类拥有父类所有特性，还可以有自己具体的特性； 多态（polymorphism）：由继承产生不同的类，对同一方法有不同的响应； ES6 类的使用 ES6 我们都很熟悉。使用 new 生成实例，会自动调用构造函数，而构造函数用 constructor 定义。 实例、构造函数、属性和方法 // es6.js class Animal { constructor(name) { this.name = name; } showName() { return `我是${this.name}` } } let animal = new Animal('动物'); console.log(animal.showName()); // 我是动物 继承与多态 派生类使用 extends 实现继承，用 super 来执行基类的构造函数。 基类即超类或父类； 派生类即子类； // es6.js class Cat extends Animal { // constructor 没有自己的属性，可不写 constructor(name) { super(name); } showName() { return `我是一只${this.name}` } } let cat = new Cat('猫'); console.log(cat.showName()); // 我是一只猫 存取器 // es62.js class Animal { constructor(name) { this.name = name; } get newName() { return `获取: ${this.name}`; } set newName(value) { this.name = `新的${value}` } } let animal = new Animal('动物'); animal.newName = '大动物'; console.log(animal.newName); 静态方法 就是使用 static 定义方法，仅供自己使用，所以无需实例化，实例不能调用。 // es63.js class Animal { static isAnimal(animal) { return animal instanceof Animal; } } let animal = new Animal('动物'); console.log(Animal.isAnimal(animal)); // true console.log(animal.isAnimal(animal)); // TypeError: animal.isAnimal is not a function ES7 类的用法 实例属性 ES6 中实例属性都是在构造函数 construction 中定义，在 ES7 中直接在类里面写就可以了。 // es64.js class Animal { name = '动物'; constructor() { // ... } } let animal = new Animal(); console.log(animal.name); // 动物 静态属性 既然实例属性可以直接在类中直接定义，那静态属性也可以这样 // es65.js class Animal { static name = '动物'; constructor() { // ... } } let animal = new Animal(); console.log(Animal.name); // 动物 console.log(animal.name); // undefined Typescript 类的用法 新增了显眼并不新鲜的修饰符 public、private、protected 和 readonly。 public 所修饰的属性和方法是公共的，任意使用； private 所修饰的属性和方法是私有的，仅供类自身使用； protected 所修饰的属性和方法是受保护的，仅供类自身和子类使用； readonly 所修饰的属性是只读的，必须在声明时或构造函数里被初始化； // class.ts class Star { public name: string = 'pr'; protected age: number = 18; private weight: number = 90; readonly gender: string = '女'; public constructor(name: string, age: number, weight: number, gender: string) { this.name = name; this.age = age; this.weight = weight; this.gender = gender; } } class ChinaStar extends Star { constructor(name: string, age: number, weight: number, gender: string) { super(name, age, weight, gender); } showName(){ return `我是${this.name}` } showAge(){ return `我实际年龄${this.age}` } showWeight(){ return `我的体重${this.weight}` } showGender(){ return `我的性别${this.gender}` } } let pr = new ChinaStar('pr', 30, 120, '男'); pr.name = '江湖再见'; pr.age = 18; pr.weight = 100; pr.gender = '女'; console.log(pr.name); console.log(pr.age); console.log(pr.weight); console.log(pr.gender); console.log(pr.showName()); console.log(pr.showAge()); console.log(pr.showWeight()); console.log(pr.showGender()); // 0.0.9/class.ts:29:28 - error TS2341: Property 'weight' is private and only accessible within class 'Star'. // 29 return `我的体重${this.weight}` // 0.0.9/class.ts:39:4 - error TS2445: Property 'age' is protected and only accessible within class 'Star' and its subclasses. // 39 pr.age = 18; // 0.0.9/class.ts:40:4 - error TS2341: Property 'weight' is private and only accessible within class 'Star'. // 40 pr.weight = 100; // 0.0.9/class.ts:41:4 - error TS2540: Cannot assign to 'gender' because it is a read-only property. // 41 pr.gender = '女'; // 0.0.9/class.ts:44:16 - error TS2445: Property 'age' is protected and only accessible within class 'Star' and its subclasses. // 44 console.log(pr.age); // 0.0.9/class.ts:45:16 - error TS2341: Property 'weight' is private and only accessible within class 'Star'. // 45 console.log(pr.weight); 从例子中可看到 只有属性 name 能在实例中使用； 只有属性 name 和 age 能在子类中使用； 无法分配给“gender”，因为它是只读属性； 注: 基类的构造函数使用 this 的属性之前必须调用 super()，这是 Typescript 的一项要求。 抽象类 不被实例化，只给基类使用。可用关键字 Abstract 定义抽象类和其内部定义的抽象方法。不同于接口，抽象类可以包含成员的实现细节。 // abstract.ts abstract class Animal2 { abstract say(): void; move(): void{ console.log('移动'); } } 抽象类中的抽象方法不含具体实现（这点和接口很相似，都定义了方法签名不含方法体），但必须在派生类中实现。 // abstract2.ts // 抽象类 abstract class AbstractPerson { constructor(public name: string, public age: number, public weight: number) { } showName(): string { return `我的名字是${this.name}`; } abstract showAge(): void; } // 基类 class Person extends AbstractPerson { constructor(name: string, age: number, weight: number) { super(name, age, weight); } showAge(): void { console.log(`我的年龄${this.age}`) } showWeight(): void { console.log(`我的体重${this.weight}`) } } let person1: AbstractPerson; let person2: AbstractPerson; person1 = new AbstractPerson('pr', 30, 110); person2 = new Person('pr', 30, 110); console.log(person2.showName()); person2.showAge(); person2.showWeight(); // 0.0.9/abstract2.ts:29:11 - error TS2511: Cannot create an instance of an abstract class. // 29 person1 = new AbstractPerson('pr', 30, 110); // 0.0.9/abstract2.ts:34:9 - error TS2339: Property 'showWeight' does not exist on type 'AbstractPerson'. // 34 person2.showWeight(); 不能给抽象类生成实例； 方法 showWeight 在抽象类 AbstractPerson 中上不存在； 本次代码 Github You can 上一篇：Typescript 枚举 下一篇：Typescript 类与接口 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/class_interfaces.html":{"url":"advanced/class_interfaces.html","title":"Typescript 类与接口","keywords":"","body":"前面章节 Typescript 对象类型-接口，主要讲接口对对象属性的类型描述。 本章说道另一作用，可以说当对象遇到接口，给你不一样的精彩。 类接口的实现 通常，一个类只继承另一个类。有时，不同类之间有一些共有的特性，把这些特性提取出来可以提高效率，提取出来的就是接口，用关键字 implements 标识。 举个例子如下 手机是一个类； 华为是手机的子类； 拍照是华为手机的一个功能（方法）； 数码相机也有拍照功能； 拍照可以抽取出来作为一个接口，华为手机和数码相机都去实现它； // classInterfaces.ts // 拍照 interface Photo { photo(): string; } // 闪光灯 interface Lamp { lampOn(): void; lampOff(): void; } // 手机超类 class Phone {} // 手机派生类 class HuaweiPhone extends Phone implements Photo, Lamp { photo(): string { return '华为拍照'; } lampOff(){} lampOn() {} } // 数码相机 class DigitalCamera implements Photo, Lamp { photo(): string { console.log('数码拍照') } } // 0.1.0/classInterfaces.ts:25:7 - error TS2420: Class 'DigitalCamera' incorrectly implements interface 'Lamp'. // Type 'DigitalCamera' is missing the following properties from type 'Lamp': lampOn, lampOff // 25 class DigitalCamera implements Photo, Lamp { // 0.1.0/classInterfaces.ts:26:14 - error TS2355: A function whose declared type is neither 'void' nor 'any' must return a value. // 26 photo(): string { 上面报错在于 DigitalCamera 实现了接口 Lamp，可却没有定义里面的方法； 接口 Phone 中 photo 需要返回 string，可是类 DigitalCamera 中的 phone 没有返回值； 你会发现 一个类可以实现多个接口; 类 HuaweiPhone 中 lampOff 和 lampOn 并没有按照接口 Lamp 按顺序定义，这说明类型检查器不会检查属性或方法的顺序，只要有相应的属性或方法且类型也是对的就可以了； 接口继承接口 我们知道类可以继承类，其实接口也可以传承接口。这种方式可以灵活地将接口分割到可重用的模块里。 // classInterfaces2.ts interface Lamp { lampOn(): void; lampOff(): void; } interface wx { wxNumber: number; showWxNumber(): string; } // 拍照 interface Photo extends Lamp, Tel { photo(): string; } // 华为手机 class HuaweiPhone2 implements Photo { public wxNumber: number; photo(): string { return '华为手机 mate20 pro 拍照就是酷儿'; } lampOn() {}; lampOff() {}; constructor(wxNumber: number) { this.wxNumber = wxNumber; }; showWxNumber(){ return `我的微信号：liferzy`; } } let huaweiPhone = new HuaweiPhone2(13701833766); console.log(huaweiPhone.showWxNumber()); // 我的微信号：liferzy console.log(huaweiPhone.photo()); // 华为手机 mate20 pro 拍照就是酷儿 你还会发现：一个接口可以继承多个接口，创建出多个接口的合成接口。 注：类 DigitalCamera 要记得把方法 lampOn、lampOff、photo 和 showWxNumber 加上。 接口继承类 我们看过类实现接口，接口继承接口，那接口能继承类吗？ // classInterfaces3.ts class Xy { x: number; y: number; } interface Xyz extends Xy { z: number; } let xyz: Xyz = { x: 1, y: 2, z: 3 }; 函数类型 在 Typescript 函数类型 文章中，函数类型表示的招式之一就是接口，其例子是 // function5.ts interface Function5 { (x: string, y: string): boolean } let function5: Function5 = (x: string, y: string) => { return x.search(y) > -1; } 这里补充下：对于函数类型的类型检查，函数的参数名可以不与接口里定义的参数名一致，比如 // function5_2.ts interface Function5_2 { (x: string, y: string): boolean } let function5_2: Function5_2 = (name: string, firstName: string) => { return name.search(firstName) > -1; } console.log(function5_2('pr is a boy', 'pr')); // true 混合（丰富）类型 接口牛逼之处可以描述 JavaScript 里丰富的类型。需求场景有时需要一个对象可以同时具有多种类型。 // classInterfaces5.ts interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { const counter = function(start: number) {}; counter.interval = 1; counter.reset = () => {}; return counter; } let c = getCounter(); c(1); c.interval = 2; c.reset(); 本次代码 Github You can 上一篇：Typescript 类 下一篇：Typescript 别名和字符串字面量类型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/alias_string_literal.html":{"url":"advanced/alias_string_literal.html","title":"Typescript 别名和字符串字面量类型","keywords":"","body":"类型别名 别名，顾名思义，就是给一个类型起个新名字便于记忆和使用。下面例子让你秒懂并应用 // alias.ts type Name = string; type ShowName = () => string; // Typescript 中的 => type NameOrShowName = Name | ShowName; // 联合类型 const getName = (name: NameOrShowName) => { // ES6 中的 => if(typeof name === 'string'){ return name; } else { return name(); } } let showName = () => 'pr is a boy'; console.log(getName('pr')); // pr console.log(getName(showName())); // pr is a boy 注：不要混淆了 TypeScript 中的 => 和 ES6 中的 => 在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型; 在 ES6 中，=> 叫做箭头函数; 当然，Typescript 有可以使用箭头函数，只不过上面是想说明两者的区别; 发现： 1.创建别名需要使用关键字 type； 2.使用别名通常用在有联合类型的场景下； 发现 创建别名需要使用关键字 type； 使用别名通常用在有联合类型的场景下； 本次代码 Github 字符串字面量类型 它是用来约束只能从定义的字段中取值。 // string.ts type EventNames = 'click' | 'scroll' | 'mousemove'; const handleEvent: (a: Element, b: EventNames) => string = (ele: Element, event: EventNames) => { return `${ele} ${event}`; } handleEvent(document.getElementById('header'), 'scroll'); handleEvent(document.getElementById('footer'), 'keyup'); // 0.1.1/string.ts:7:48 - error TS2345: Argument of type '\"keyup\"' is not assignable to parameter of type 'EventNames'. // 7 handleEvent(document.getElementById('footer'), 'keyup'); 上面报错是因为 keyup 不在 EventNames 中。 发现 定义类型别名与字符串字面量类型用的都是 type。 You can 上一篇：Typescript 类与接口 下一篇：Typescript 泛型 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/generics.html":{"url":"advanced/generics.html","title":"Typescript 泛型","keywords":"","body":"泛型，字面上看就是宽泛的类型约束。是指在定义函数、接口或类的时，不指定类型，在使用时指定类型（runtime）。 使用场景 考虑到重用性和扩展性，因为组件除了支持当前数据类型，还要考虑未来需要支持新的类型，这是一个合格程序员应有的素养和一个好系统的衡量标准之一（功能的灵活性）。 泛型变量 设计一个函数：输入什么类型，输出也是什么类型 // generics.ts function same(arg: number): number { return arg; } console.log(same(18)); // 18 这个只适合数字类型，换成字符串就得再写一个，无重复性可言，那就得改造 // generics2.ts function same2(arg: any): any { return '十八'; } console.log(same2(18)); // 十八 没报错，但是违背了输入类型和输出类型相同这个要求。 重点来了，我们需要 // generics3.ts function same3(arg: T): T { return '十八'; } console.log(same3(18)); function same3_1(arg: T): T { return arg; } console.log(same3_1(18)); console.log(same3_1('十八')); // 0.1.2/generics3.ts:2:5 - error TS2322: Type '\"十八\"' is not assignable to type 'T'. // '\"十八\"' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint '{}'. // 2 return '十八'; 剖析下 例子中在函数名 same3 后面添加 （可理解为定义类型变量，你也可以叫 S）； T 本身理解为类型变量，输入类型（18 和 十八）时就是赋值这个类型变量是什么类型（对应 number 和 string）； 后面可以继续使用这个类型变量 T 来约束输出类型； 函数使用时，可在函数名后强制定义输入类型 same3_1(18); 函数使用时，也可以不强制定义输入类型 same3_1('十八')，这是利用类型推论（编译器根据输入类型自动帮助捕获 T的类型），很显然这个使用简单，推荐使用; 最后，函数 same3_1 可以适合任何类型，管它叫泛型也是实至名归，恭喜你 same3_1; 多个类型变量 有时，参数也不止一个，多个情况下 // generics4.ts function info(name: S, age: N): [S, N] { return [name, age]; } console.log(info('pr', 18)); // [ 'pr', 18 ] 泛型类型 // generics4_1.ts const generics4_1 = (arg: T): T => { return arg; } let generics4_1_1: (arg: S) => S = generics4_1; console.log(generics4_1(18)); // 18 console.log(generics4_1_1('十八')); // 十八 泛型函数的类型与非泛型函数的类型区别在于：是否有一个类型参数在最前面 、； 可以使用不同的泛型参数名 T、S，只要数量上和使用方式上对应上就好了； 泛型接口 // generics4_2.ts interface Generics4_2 { (arg: S): S; } const generics4_2 = (arg: T): T => { return arg; } let generics4_2_1: (arg: T) => T = generics4_2; let generics4_2_2: { (arg: S): S } = generics4_2; // 对象字面量 let generics4_2_3: Generics4_2 = generics4_2; // 泛型接口 console.log(generics4_2(18)); // 18 console.log(generics4_2_2('十八')); // 十八 console.log(generics4_2_2('pr')); // pr 可以使用带有调用签名的对象字面量 { (arg: S): S } 来定义泛型函数; 可以使用泛型接口 Generics4_2 来定义泛型函数; 泛型类 其实和泛型接口很像，一起看看，顺便对比下 // genericsClass.ts class Sum { zero: T; add: (x: T, y: T) => T } const sum = new Sum(); sum.zero = 0; sum.add = (x, y) => (x + y); console.log(sum.add(5, 6)); // 11 const sum1 = new Sum(); sum1.zero = '0'; sum1.add = (x, y) => (x + y); console.log(sum1.add('5', '6')); // 56 通过 sum 和 sum1 你会发现不仅仅限为 number，string 也可以； 与接口一样，泛型类型放在类后面，可以直观地确认类的属性都在用相同类型； 泛型约束 上面例子的函数体过于简单，对于参数的属性或方法并没有使用。由于我们事先并不知道输入参数是什么类型，不能贸然使用参数的属性，比如输入参数是数字，我们知道数字没有 length 属性，看看 Typescript 给我们报什么错（有点找茬的意思哈）。 // generics5.ts function same5(arg: T): T { console.log(arg.length); return arg; } console.log(same5(18)); console.log(same5('十八')); // 0.1.2/generics5.ts:2:21 - error TS2339: Property 'length' does not exist on type 'T'. // 2 console.log(arg.length); 如我们推测的一样，泛型 T 在不知道什么类型的情况下不知道是否包含属性 length，所以编译报错了。 那如何解决呢？万能的接口可以帮助我们 // generics6.ts interface Length { length: number; } function same6(arg: T): T { console.log(arg.length); return arg; } console.log(same6(18)); console.log(same6('十八')); console.log(same6(['pr', '30', 'boy'])); // 0.1.2/generics6.ts:9:19 - error TS2345: Argument of type '18' is not assignable to parameter of type 'Length'. // 9 console.log(same6(18)); 解释下 使用 extends 继承接口 Length 来约束泛型 T 符合接口属性，说人话就是输入的类型必须包含 length 属性了 字符串 十八 和数组 ['pr', '30', 'boy'] 符合要求，数字 18 明显不符合要求了； 那多个参数的泛型约束怎么处理？ // generics7.ts function info2(name: S, age: N): [S, N] { return [name, age]; } console.log(info2('pr', 18)); console.log(info2(30, 18)); // 0.1.2/generics7.ts:5:19 - error TS2345: Argument of type '\"pr\"' is not assignable to parameter of type 'number'. // 5 console.log(info2('pr', 18)); 报错原因在于，参数 pr 不能分配给类型 number 的参数。 本次代码 Github You can 上一篇：Typescript 别名和字符串字面量类型 下一篇：Typescript 声明文件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/declaration_files.html":{"url":"advanced/declaration_files.html","title":"Typescript 声明文件","keywords":"","body":"通常我们使用第三方库，可以 在 HTML 中通过 标签引入; CMD 或 AMD 方式引入; ES6 语法 import 引入; 看那些年我们用过的 jQuery 看惯了之前的引入方式，那 Typescript 咋用的呢？看下面这个例子 // declareVar.ts declare var $$: (selector: string) => any; $$('#root'); 编译后 // declareVar.js $$('#root'); 可见 declare var 只是定义一个全局变量的类型（不是定义一个全局变量），仅在编译时用于检查，不会存在与编译的结果中。 声明文件 存放声明语句的文件，叫声明文件，通常格式为 xxx.d.ts。还是拿 jQuery 举例 1.声明文件 jQuery.d.ts（抽离出生命语句） // jQuery.d.ts declare const jQuery2: (selector: string) => any; 2.typescript 文件 // declareVar2.ts jQuery2('#root'); 3.编译后 jQuery2('#root'); jQuery.d.ts 文件与 declareVar2.ts 同处一个目录； declare const jQuery2 这是全局变量声明模式； 通常，ts 会解析所有 *.ts 文件（含 *.d.ts）,所以 declareVar2.ts 可以获得 jQuery2 类型定义； 第三方声明文件 既然像 jQuery.d.ts 这类很多人都需要的声明文件，社区肯定会做些什么，比如 DefinitelyTyped jQuery。既然社区都写好了，那就不造轮子直接下载咯。关于下载，可将其下载到本地 @types 目录下，便于识别与统一管理这类声明文件。 npm install @types/jquery // declareVar3.ts const jQuery = require('jquery'); const $ = require('jquery'); jQuery('#root') $('#root') 对于社区为哪些第三方库写了声明文件，可在这里查询 https://microsoft.github.io/TypeSearch/ 声明合并 实际场景中，对于定义了两个相同名字的函数、接口或类，它们会合并成一个类型。 函数的合并 看个回文的例子 // functionMerge.ts function palindrome(x: string): string; function palindrome(x: number): number; function palindrome(x: string | number): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } console.log(palindrome('pr18')); // 81rp 接口的合并 就是将各接口的属性合并起来。 // interfaceMerge.ts interface Station { name: string; time: string; showName(): string; } interface Station { name: string; time: number; showTime(): string; } let station: Station = { name: '前端工程师', time: 18, showName: function() { return `我是一名${this.name}`; }, showTime: () => { return `工作已有${station.time}年了`; } } console.log(station.showName()); // 我是一名前端工程师 console.log(station.showTime()); // 工作已有8年了 // 0.1.3/interfaceMerge.ts:8:5 - error TS2717: Subsequent property declarations must have the same type. Property 'time' must be of type 'string', but here has type 'number'. // 8 time: number; // 0.1.3/interfaceMerge.ts:3:5 // 3 time: string; // 'time' was also declared here. // 0.1.3/interfaceMerge.ts:14:5 - error TS2322: Type 'number' is not assignable to type 'string'. // 14 time: 18, // 0.1.3/interfaceMerge.ts:3:5 // 3 time: string; // The expected type comes from property 'time' which is declared here on type 'Station' 上面报错原因是重复定义 age 时改变了其类型。可见，接口的属性在多个接口中可重复定义，但其类型必须唯一。 类的合并 和接口的合并一样，就不写了。 命名空间的合并 // namespaceMerge.ts namespace NamespaceMerge { export function one(){} } namespace NamespaceMerge { export function two(){} } NamespaceMerge.one(); 这里必须要导出，因为不导出就算是合并了，外面也是访问不到，看下图 本次代码 Github 你可以... 上一篇：TTypescript 泛型 下一篇：Typescript 书写声明文件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/declaration_files_write.html":{"url":"advanced/declaration_files_write.html","title":"Typescript 书写声明合并","keywords":"","body":"通常，常用的声明文件，社区都帮我们做好了。在此作为笔记分享，还是要了解下当第三方库没有时，自己该如何书写。在动手前，先分析下场景： 全局变量 最简单直接，通过标签 引入，注入全局变量 xxx； npm install @types/xxx --save-dev 安装，不许任何配置； 声明文件 xxx.d.ts 存放当前项目中，建议和其他 *.ts 都存放在 src 目录下（没有生效，可检查 tsconfig.json 中的 file、include、exclude 等配置）； 声明语句 含义 举例 declare var、declare const、declare let 声明 全局变量 declareVar.ts declare function 声明 全局方法 declareFunction.ts declare class 声明 全局类 declareClass.ts declare enum 声明 全局枚举类型 declareEnum.ts declare namespace 声明 全局对象 declareNamespace.ts interface、type 声明 全局类型 declareInterface.ts 和 declareType.ts declare var、declare const、declare let // jQuery2.d.ts declare const jQuery2: (selector: string) => any; // declareVar2.ts jQuery2('#root'); declare function // declareFunction.d.ts declare function declareFunc(selector: string): any; // declareFunction.ts declareFunc('#root'); declare class // declareClass.d.ts declare class DeclareClass { name: string; constructor(name: string); showName(): string; } // declareClass.ts let declareClass = new DeclareClass('class'); declare class 只定义类型，不具体实现（ 例子中 showName2 是具体实现所以报错了）。 declare enum // declareEnum.d.ts declare enum DeclareEnum { man, woman } // declareEnum.d.ts let person = [ DeclareEnum.woman, DeclareEnum.man ]; declare namespace namespace 第一次见，是 ts 早期为了解决模块化造的关键字，顾名思义是命名空间的意思。 由来：前面说了 ts 用 namespace 解决模块化，那模块化单词是 module，可后来 ES6 也是用了 module，由于 ts 要兼容 ES6，不得已将 module 改为 namespace。 不建议用：ES6 的出现，ts 不建议再用 namespace 来解决模块化问题，而是推荐使用 ES6 的模块化方案（ts 还是很包容的，一切为了程序员的便利）。 了解其原理：虽然 namespace 不建议用了，但 declare namespace 还是常用的，表示全局变量的一个对象，所以就有子属性。 // declareNamespace.d.ts declare namespace declareNamespace { const name: string; function showName(name: string): void; class Gender { showGender(gender: string): void; } enum Direction { up, right, down, left } namespace ns { function showNs(name: string): void; } } // declareNamespace.ts declareNamespace.showName('declareNamespace'); declareNamespace.ns.showNs('ns'); 注：在声明对象中可继续嵌入声明对象。 interface 和 type // interface.d.ts interface Options { position?: 'TOP' | 'BOTTOM'; data?: any; } declare namespace modal { function open(title: string, options?: Options): void; } // interface.ts let options: Options = { position: 'top', data: { width: 200 } } modal.open('新增', options); 上面 interface 没什么问题，但是它是暴露在全局类型中的，所以最好存放在 namespace 中，可改写为 // interface2.d.ts declare namespace modal { interface Options { position?: 'top' | 'bottom'; data?: any; } function open(title: string, options?: Options): void; } // interface2.ts let options: modal.Options = { position: 'top', data: { width: 200 } } modal.open('新增', options); npm 包 通过 import xxx from 'xxx' 导入，符合 ES6 模块规范。知道怎么引入 npm 包，还得知道怎么去创建 npm 包。 声明文件存放位置 和 npm 包绑定在一起（npm 发布者也提供了声明文件，良心发布者） 场景是当接手一个项目，一是查找其 npm 包可看 package.json 中的 types，二是查看有无 xxx/index.d.ts 声明文件。为了便于自己和他人，请将声明文件和 npm 包绑定在一起（如果以后自己发布 npm 包）。 在社区的 @types（没有和 npm 包绑定在一起，由其他人发布） 由于种种情况，有的 npm 包并没有声明文件，这个时候试着安装 xxx（npm install @types/xxx -S）来判断 @types 是否存在声明文件（为了在 ts 便利使用，其他人补足了对应的声明文件，但只能发布到 @types 里）。 上面两种情况都没有找到声明文件，那就得自己动手写声明文件了（靠人不如靠己） 一是创建在 node_modules/@types/xxx/index.d.ts，这种方式不需要额外配置（好处），但是 node_modules 是不稳定的，因为 node_modules 目录不会发布到仓库、无法版本回溯、有删除风险、多人团队应用乱等问题，所以不建议使用；二是创建 types 目录，专门存放自己写的声明文件，如 @types/xxx/index.d.ts，此刻需要 tsconfig.json 配合，成功规避掉第一种方法产生的问题； 目录如下（最简单清爽但实用） project ├── src | └── index.ts ├── types | └── xxx | └── index.d.ts └── tsconfig.json tsconfig.json 内容 { \"compilerOptions\": { \"module\": \"commonjs\", \"baseUrl\": \"./\", \"paths\": { \"*\": [\"types/*\"] } } } 声明文件语法 语法 含义 示例 export 导出变量 types/export/index.d.ts 和 0.1.3/export.ts export namespace 导出对象(含子属性) types/export/index.d.ts 和 0.1.3/export.ts export default 导出默认(ES6)（推荐） types/exportDefault/*.d.ts 和 0.1.3/exportDefault.ts export = commonjs 导出模块（不推荐） export 导出变量 前面谈到过全局变量的声明文件方式，npm 包声明文件和其有一定区别。 不使用 declare 声明全局变量，就只是声明一个普通变量（局部变量）； 声明文件中使用 export 导出； 使用文件用 import 导入然后使用，这个和 ES6 一样（无学习成本）； 下面就自己创建声明文件，推荐写在 types 目录下，后续也是如此。 // types/export/index.d.ts export const name: string; export function showName(): string; export class Star { constructor(name: string); say(): string; } export enum Gender { woman, man } export interface Options { position?: 'TOP' | 'BOTTOM'; data?: any; } export namespace declareNamespace { const name: string; namespace ns { function showNs(name: string): string; } } // 0.1.3/export.ts import { name, showName, Star, Gender, Options, declareNamespace } from '../types/export'; console.log(name); let myName = showName(); let newStar = new Star('pr'); let gender = [Gender.woman, Gender.man]; let options: Options = { position: 'TOP', data: { name: 'pr', age: 18 } } console.log(declareNamespace.name); declareNamespace.ns.showNs('ns'); export default 导出默认（ES6） export default 无论是 ES6 还是 Typescript 都是直接默认导出。在 Typescript 中可直接导出 function、class 和 interface。 // types/exportDefault/function.d.ts export default function showName(): string; // types/exportDefault/class.d.ts export default class Star { constructor(name: string); say(): string; } // types/exportDefault/interface.d.ts export default interface Options { position?: 'TOP' | 'BOTTOM'; data?: any; } // types/exportDefault/enum.d.ts declare enum Gender { woman, man } export default Gender; // types/exportDefault/namespace.d.ts declare namespace declareNamespace { const name: string; namespace ns { function showNs(name: string): string; } } export default declareNamespace; export = 导出模块 commonjs 规范中，导出一个模块可以 // 导出整体 module.exports = xxx; // 导出单个 exports.xxx = xxx; 在 Typescript 中，对于 commonjs 模块导出，有多种导入方式 // 导入整体 const xxx = require('xxx'); import * as xxx from 'xxx'; import xxx = require('xxx'); // 导入单个 const fn = require('xxx').fn; import { fn } from 'xxx'; import fn = xxx.fn; 注：import ... require 和 export = 都是 Typescript 为了兼容 AMD 规范和 commonjs 规范创建的语法，由于不常用所以也不推荐用。而是推荐使用 ES6 标准的 export default 和 export(大家都这么用)。 UMD 库 通用模块定义（Universal Module Definition），UMD 库指那些可以通过 标签引入，又可以通过 import 导入的库。和 npm 包的声明文件不同的是，需要额外声明一个全局变量。 // types/umd/index.d.ts export as namespace umd; export default umd; // export = umd; declare function umd(): string; declare namespace umd { let ns: string; function showNs(ns: number): string; } // 0.1.3/umd.ts import umd from '../types/umd'; umd(); umd.ns = '18'; umd.showNs(18); 扩展全局变量 // extendVar.ts interface String { prefixName(): string; } 'pr'.prefixName(); 可见，通过声明，String 也可添加属性和方法。 对于来自 npm 包或 UMD 库的声明文件，需要 export 导出类型声明。如果希望 npm 包或 UMD 库本身导入后扩张全局变量，可用 declare global。 // declareGlobal.ts 本次代码 Github 你可以... 上一篇：TTypescript 声明文件 下一篇：Typescript 代码检查 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"action/":{"url":"action/","title":"实战篇","keywords":"","body":"实战篇 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"file/":{"url":"file/","title":"附件篇","keywords":"","body":"附件篇 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}